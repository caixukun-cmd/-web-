# 时间管理模型使用指南

本文档介绍智能小车仿真系统中的新时间管理模型，帮助用户理解各个命令的时间行为。

## 核心概念

### 1. 非阻塞运动控制
- 所有的运动命令（如 `car.forward()`, `car.backward()`）都是**非阻塞的**
- 这些命令只设置运动参数，然后立即返回，不会等待运动完成

### 2. 仿真主循环控制
- 运动的实际执行由仿真主循环控制
- 主循环使用时间增量（delta_time）来精确计算位置更新

### 3. `get_position()` 的行为
- `get_position()` 返回的是**当前仿真帧的快照**
- 如果在运动命令后立即调用，返回的是运动开始前或刚开始时的位置
- 用户应理解，获取的位置可能没有反映出最新的运动结果

### 4. `car.wait()` 方法
- `car.wait()` 用于等待当前运动完成
- 该方法会持续检查小车是否仍在运动（通过 `has_active_motion()`）
- 只有当运动完成后才会返回

## API 说明

### 运动控制方法

#### `car.forward(speed, duration)`
- **参数**: 
  - `speed`: 速度值 (0-100)
  - `duration`: 持续时间（秒）
- **行为**: 设置小车向前运动，立即返回
- **注意**: 不会等待运动完成

#### `car.backward(speed, duration)`
- **参数**: 
  - `speed`: 速度值 (0-100)
  - `duration`: 持续时间（秒）
- **行为**: 设置小车向后运动，立即返回
- **注意**: 不会等待运动完成

#### `car.turn_left(angle)` 和 `car.turn_right(angle)`
- **参数**: `angle` - 转向角度
- **行为**: 立即改变小车方向
- **注意**: 转向是瞬时操作，不影响运动持续性

#### `car.stop()`
- **行为**: 立即停止小车运动

#### `car.get_position()`
- **返回**: 当前仿真状态的快照
- **重要**: 返回的是调用时刻的位置，不是运动结束后的最终位置

#### `car.wait()`
- **行为**: 等待当前所有运动完成
- **使用场景**: 在需要确保运动完成后才继续执行时使用

## 使用模式

### 模式1: 等待运动完成
```
print("起始位置:", car.get_position())
car.forward(80, 3.0)
await car.wait()  # 等待运动完成
print("最终位置:", car.get_position())  # 这是运动完成后的实际位置
```

### 模式2: 不等待运动完成
```
print("起始位置:", car.get_position())
car.forward(80, 3.0)
print("运动中位置:", car.get_position())  # 这可能是运动过程中的位置
# 运动仍在继续...
```

### 模式3: 顺序执行多个动作
```
# 前进一段距离
car.forward(60, 2.0)
await car.wait()  # 等待前进完成

# 转向
car.turn_right(90)
await asyncio.sleep(0.5)  # 短暂停顿让转向完成

# 再前进
car.forward(60, 2.0)
await car.wait()  # 等待第二次前进完成
```

## 常见陷阱和最佳实践

### ❌ 错误做法
```
car.forward(80, 3.0)
pos = car.get_position()  # 错误：这会得到运动开始时的位置
```

### ✅ 正确做法
```
car.forward(80, 3.0)
await car.wait()  # 等待运动完成
pos = car.get_position()  # 正确：这会得到运动完成后的最终位置
```

### ⚠️ 注意事项
1. **time.sleep() 无效**: 在仿真环境中，`time.sleep()` 不会真正阻塞，而是记录延时意图
2. **仿真独立运行**: 即使用户代码执行完毕，仿真循环仍会继续直到运动完成
3. **并发控制**: 多个运动命令会覆盖彼此，通常只执行最后一个命令

## 性能考虑

- 仿真循环以固定间隔（默认50ms）更新位置
- 时间增量被限制在0.1秒以内，防止时间跳跃造成的位置突变
- 所有计算都是非阻塞的，确保用户代码流畅执行

## 超时保护

- 系统包含超时保护机制，防止单次运动执行时间过长
- 默认最大等待时间为10秒，超过此时间将强制停止运动
- 超时时会发送警告消息，提示用户运动已被强制停止
